#!/usr/bin/perl

use POSIX; 
use List::Util qw(sum min max);
use File::Copy qw(copy);
use File::Copy qw(move);

#
# These software tools are currently
# Licensed under the Academic Free License version 3.0
# The authors hold no responsibility whatsoever for any software 
# or hardware related damages that can occur as a result of the use of these codes.
#
# See https://opensource.org/licenses/AFL-3.0 for the details.

# # updated version 1.1 eric chan 2015
#   now has optins for boundary and replicate 
# 
#
#  master perl script that uses msi2lmp to create the correct input files for  
#  conversion of MSI insightII format to LAMMPS format.   
#
# note that in the drieding FF all improper types have Chi0 = 0 
# with the exception of  SP3 Carbon with implict hydrogen (which is rarely used these days)
# so the values have been set here manually for improper_style harmonic    
#
# ad hoc depending on the system you are running from 
#
#  run by typing ./fix_msi2lmp_out.pl rootname boundary replicate improper_flag
#
# where
# 
# - boundary should be an "s" or "p" 
#
# - replicate should be an integer which represents the size of the supercell
# a 1 will cause no replicate comand to be present in the input file 
# 
# - the improper_flag can be set to "none" to turn off the improper_style 
#   since some molecules have no improper angle eg. alkanes 
#   all other arguments or blank will casue the normal output 
#
# to get the original output 
# type ./fix_msi2lmp_out.pl rootname s 1  
#
# to get the output  without improper_style initailized 
# type ./fix_msi2lmp_out.pl rootname s 1 none 
#    
#
####################################
#
# put the contents of the driver input here 
#
####################################


 my $rootname = $ARGV[0] ; 
 my $boundary = $ARGV[1] ; 
 my $replicate = $ARGV[2] ; 
 my $improper_flag = $ARGV[3] ; 

# my $frc_file = '/Users/ericchan/Work/Molecular_Modeling/LAMMPS/frc_files/cvff_dreiding.frc' ; 
 my $frc_file = '/Users/ericchan/Work/python_stuff/erics_modules/mol2lammps_distr/frc_files/cvff_dreiding.frc' ;
 my $lmpdata_file = "$rootname.data";
 my $lmpdata_new = "$rootname.data.new";

# copy $lmpdata_file, $lmpdata_new ; 

print $frc_file , "\n"  ;
print $lmpdata_file,  "\n";  

#  run the MSI2LMP command 
system("msi2lmp.exe $rootname -frc $frc_file");

print "gathering data from .frc \n"; 
#  grab the parameters we need to make corrections  
# one of the disadvantagess of perl is the way you can pass data using subroutines 
# for now get this to work and then you can change it over to python if you have to edit again.
# becasue using array references for subroutines is tricky
#####################################################################
  my ($torsion_label_ref, $Kphi_ref, $n_ref, $Phi0_ref) = get_torsion_data($frc_file);

 my @torsion_labels = @$torsion_label_ref ;
 my @Kphis = @$Kphi_ref ;
 my @ns = @$n_ref ;
 my @Phi0s = @$Phi0_ref ;

#
# $tor_num =  @torsion_labels ;
# for (my $i=0; $i<=$tor_num; ++$i) {
#   print "$torsion_labels[$i]\n";
# }
# 

 my ($nonbond_label_ref, $eps_ref, $Rmin_ref) = get_nonbond_data($frc_file);
 my  @nonbond_labels = @$nonbond_label_ref ;
 my  @eps = @$eps_ref ;
 my  @Rmins = @$Rmin_ref ;

####################################################################################
# now begin reading through the data file and editing 
##############################################################
# 
print "fixing up data file  \n"; 
#
open (newlmpdata, ">$lmpdata_new") ;
# open the raw data file generated by MSI2LMP  
open (lmpdata, $lmpdata_file) ;

# get out the header data and use this to parse the rest of the file 
while(<lmpdata>) { 
    
  if (/atoms/) {  @line = split ;  $num_atoms = sprintf "%d", $line[$1];} 
  if (/bonds/) {  @line = split ;  $num_bonds =  sprintf "%d", $line[$1];} 
  if (/angles/) {  @line = split ;  $num_angles =  sprintf "%d", $line[$1];} 
  if (/dihedrals/) {  @line = split ;  $num_dihedrals =  sprintf "%d", $line[$1];} 
  if (/impropers/) {  @line = split ;  $num_impropers =  sprintf "%d", $line[$1];} 

  if (/atom types/) {  @line = split ;  $num_atom_types = sprintf "%d", $line[$1];} 
  if (/bond types/) {  @line = split ;  $num_bond_types =  sprintf "%d", $line[$1];} 
  if (/angle types/) {  @line = split ;  $num_angle_types =  sprintf "%d", $line[$1];} 
  if (/dihedral types/) {  @line = split ;  $num_dihedral_types =  sprintf "%d", $line[$1];} 
  if (/improper types/) {  @line = split ;  $num_improper_types =  sprintf "%d", $line[$1];} 
 
   last if (/Masses/);
  
  print newlmpdata $_ ;

             } 
  print newlmpdata "Masses\n" ;

##############################
# now at some sections you need to make a check to see if there are any coefficents 
# if so then loop through them 
# in most cases there are all types of coefficents
###################

 # go through atoms types   
 for (my $i=0; $i <= $num_atom_types+1; ++$i) { 
            $line = <lmpdata> ;  print newlmpdata $line ; 
                            }

 # go through pair types 
            $line = <lmpdata> ;  print newlmpdata "Pair Coeffs\n"  ; 
            $line = <lmpdata> ;  print newlmpdata $line ; 
 for (my $i=1; $i <= $num_atom_types; ++$i) { 
              $line = <lmpdata> ;
             @words = split(' ',$line); 
                       $typenum =  $words[0] ; 
                       $atomtype =  $words[4] ; 
                     ($eps,$Rmin) = get_pair_coeffs($atomtype) ; 
                print newlmpdata "   $typenum   $eps   $Rmin   # $atomtype \n" ; 
                            }
            $line = <lmpdata> ;  print newlmpdata $line ; 

 # go through bond types 
   if($num_bonds != 0){
            $line = <lmpdata> ;  print newlmpdata "Bond Coeffs\n"  ; 
            $line = <lmpdata> ;  print newlmpdata $line ; 
 for (my $i=0; $i <= $num_bond_types; ++$i) { 
            $line = <lmpdata> ;  print newlmpdata $line ; 
                            }
                      }  # end check for bonds 

 # go through angle types 
   if($num_angles != 0){
            $line = <lmpdata> ;  print newlmpdata "Angle Coeffs\n"  ; 
            $line = <lmpdata> ;  print newlmpdata $line ; 
 for (my $i=0; $i <= $num_angle_types; ++$i) { 
            $line = <lmpdata> ;  print newlmpdata $line ; 
                            }
                    }  # end check for angles 

 # go through dihedral types 
   if($num_dihedrals != 0){
            $line = <lmpdata> ;  print newlmpdata "Dihedral Coeffs\n"  ; 
            $line = <lmpdata> ;  print newlmpdata $line ; 
 for (my $i=1; $i <= $num_dihedral_types; ++$i) { 
              $line = <lmpdata> ;
             @words = split(' ',$line); 
                       $typenum = $words[0] ; 
                       $dihedraltype = $words[5] ; 
                     ($Kphi,$n,$Phi0) = get_dihedral_coeffs($dihedraltype) ; 
                print newlmpdata "  $typenum   $Kphi  $n  $Phi0  0.0     # $dihedraltype \n" ; 
                            }
            $line = <lmpdata> ;  print newlmpdata $line ; 
                    }  # end check for dihedrals 

 # go through improper types 
 
   if($num_impropers != 0){
            $line = <lmpdata> ;  print newlmpdata "Improper Coeffs\n"  ; 
            $line = <lmpdata> ;  print newlmpdata $line ; 
 for (my $i=1; $i <= $num_improper_types; ++$i) { 
              $line = <lmpdata> ;
             @words = split(' ',$line); 
                       $typenum =  $words[0] ; 
                       $Kp = sprintf "%.6f",   $words[1] ; 
                       $X0 =  $words[2] ; 
                       $ilabel =  $words[5] ; 
                   print newlmpdata "$typenum  $Kp  0.000000  # $ilabel \n" ; 
                            }
            $line = <lmpdata> ;  print newlmpdata $line ; 
                    }  # end check for angles 


 # go through atoms  
   if($num_atoms != 0){
            $line = <lmpdata> ;  print newlmpdata "Atoms\n"  ; 
            $line = <lmpdata> ;  print newlmpdata $line ; 
 for (my $i=0; $i <= $num_atoms; ++$i) { 
            $line = <lmpdata> ;  print newlmpdata $line ; 
                            }
                      }  # end check for atoms 

 # go through bonds  
   if($num_bonds != 0){
            $line = <lmpdata> ;  print newlmpdata "Bonds\n"  ; 
            $line = <lmpdata> ;  print newlmpdata $line ; 
 for (my $i=0; $i <= $num_bonds; ++$i) { 
            $line = <lmpdata> ;  print newlmpdata $line ; 
                            }
                      }  # end check for bonds 
#
 # go through angles  
   if($num_bonds != 0){
            $line = <lmpdata> ;  print newlmpdata "Angles\n"  ; 
            $line = <lmpdata> ;  print newlmpdata $line ; 
 for (my $i=0; $i <= $num_angles; ++$i) { 
            $line = <lmpdata> ;  print newlmpdata $line ; 
                            }
                      }  # end check for bonds 

 # go through dihedrals  
   if($num_dihedrals != 0){
            $line = <lmpdata> ;  print newlmpdata "Dihedrals\n"  ; 
            $line = <lmpdata> ;  print newlmpdata $line ; 
 for (my $i=0; $i <= $num_dihedrals; ++$i) { 
            $line = <lmpdata> ;  print newlmpdata $line ; 
                            }
                      }  # end check for dihedrals 

 # go through impropers  
   if($num_impropers != 0){
            $line = <lmpdata> ;  print newlmpdata "Impropers\n"  ; 
            $line = <lmpdata> ;  print newlmpdata $line ; 
 for (my $i=1; $i <= $num_impropers; ++$i) { 
# here you need to swap I and J around  
              $line = <lmpdata> ;
             @words = split(' ',$line); 
                       $num =  sprintf "%5d", $words[0] ; 
                       $type = sprintf "%3d",   $words[1] ; 
                       $I =  sprintf "%7d", $words[2] ; 
                       $J =  sprintf "%7d", $words[3] ; 
                       $K =  sprintf "%7d", $words[4] ; 
                       $L =  sprintf "%7d", $words[5] ; 
                   print newlmpdata "$num $type $J $I $K $L\n" ; 
                            }
            $line = <lmpdata> ;  print newlmpdata $line ; 
                      }  # end check for impropers 
close(lmpdata);
close(newlmpdata);

unlink($lmpdata_file);
move $lmpdata_new, $lmpdata_file ; 

# you can edit the lammps input file below 
print "creating input file  \n"; 
create_lammps_input($rootname,$boundary,$replicate,$improper_flag); 

# you can edit the run commands below 
print "creating run file  \n"; 
create_run_file($rootname); 

print "done :)  \n"; 
#
#

# print "$num_atoms $num_bonds \n"; 


###########################################################################################
# begin subroutines
##########################################################################################


################
# create the lammps input file
#################
 sub create_lammps_input { 
       my ($rootname,$boundary,$replicate,$improper_flag) = @_ ;

 if ($boundary eq "p"){$boundary = "boundary  p p p";}
 elsif ($boundary eq "s"){$boundary = "boundary  s s s";}
 else {print "you needed to specify a \'p\' or \'s\' for the boundary condition. your LAMMPS input wont work \n";}

 $supercell_str = $replicate." ".$replicate." ".$replicate ;
# print $supercell_str ;
 if ($replicate eq 1){$replicate = "";}
 else{$replicate = "replicate ".$supercell_str;}

 if ($improper_flag eq "none") {$improper_flag = "";} 
 else {$improper_flag = "improper_style harmonic";}

$file_input = <<"END";

# $rootname

units          real
atom_style     full
$boundary

pair_style     lj/charmm/coul/charmm 8.0 12.0
# pair_style     lj/cut/coul/cut 8.0 12.0

# pair_style     lj/charmm/coul/long 8.0 12.0
# pair_style     lj/cut/coul/long 8.0 12.0
# kspace_style   ewald/disp 0.0001

dielectric     1.0
special_bonds  lj 0.000000 0.000000 1.000000 coul 0.000000 0.000000 1.000000
bond_style     harmonic
angle_style    harmonic
dihedral_style charmm
$improper_flag
# neighbor       2.0 nsq

read_data      $rootname.data
$replicate

# use these grouping commands to fix parts of the system
# group          fixed molecule <> 1 1
# group          mol2 molecule <> 2 2
# group          mobile subtract all fixed 
# fix            freeze fixed setforce 0.0 0.0 0.0

# perform optimisation
# note that you do not nessesarily need to perform a dump during the minimisation step
# so it is possibly to minimise the system and then perform MD. 
# if you want to output a minmimised molecue in .pdb format then use scale yes 
# read_data      $rootname.data
group          mobile union all
# dump           1 all atom 100 $rootname.dump
# dump_modify    1 scale yes image yes
# # dump           2 all custom 100 $rootname.frcdump fx fy fz
thermo_style   custom etotal
thermo_modify  line multi
thermo         100
thermo_modify  flush yes
min_style      cg
minimize       0.0001 0.000001 500 5000
# write_restart  $rootname.rst

# Note that in LAMMPS to calcualte the energy of the system without any iteration. i.e. single point 
# run 0

# read_data      $rootname.data
# read_dump      $rootname.dump 1 x y z ix iy iz replace yes  

# If you performed minimisiation reset the timestep to zero
# and perform equilibration run 

reset_timestep 0

timestep       1
fix            1 mobile nve
# fix            1 mobile nvt temp 298.15 298.15 10.0
# fix            1 mobile temp/berendsen 298.15 298.15 10.0
# fix            1 mobile npt temp 298.15 298.15 10.0 aniso 1.000000 1.000000 350.0
velocity       mobile create 298.15 1415810067 mom yes rot yes dist gaussian
# dump           1 all atom 5 $rootname.dump
# dump           1 all atom 100 $rootname\_equil.lammpstrj
# if you set 1 'scale no' it turns off the unit cell translations 
# dump_modify    1 scale yes image yes
# dump           2 all custom 5 $rootname.veldump vx vy vz
thermo_style   custom etotal ke pe ebond eangle edihed eimp evdwl ecoul elong temp
thermo_modify  line multi
thermo         100
thermo_modify  flush yes
# restart        1000 $rootname\_1.rst $rootname\_2.rst
run            1000
# write_restart  $rootname.rst

# to stop output to equil run
# undump  1 

# do the production run 
reset_timestep 0
dump           2 all atom 100 $rootname\_prod.lammpstrj
dump_modify    2 scale yes image yes
run            1000
# write_data $rootname\_new.data 

END

open (lmpin, ">$rootname.in") ;
print lmpin $file_input; 
close (lmpin) ;
}


################
# create the run file
#################
 sub create_run_file { 
       my ($rootname) = @_ ;

$file_input2 = <<"END2";
#!/bin/bash

# run the lammps job 
/Users/ericchan/bin/lmp_mac -in  $rootname.in |tee $rootname.out

# convert the lammps data file into a .psf and .pdb for output to other programs 
# note that the .psf file reads from the lammps .datafile so
# if you use replicate you need to create a new datafile. 
/Users/ericchan/bin/lammps2pdb.pl $rootname 

# send the production run to an .arc file given you have the .car file present 
# disabled for my macbook
# echo $rootname\_prod.lammpstrj | lmp2arc.exe -trueflags -move_mol -car $rootname.car > $rootname.arc

# read the output of the production run into vmd 
/Applications/VMD\\ 1.9.1.app/Contents/MacOS/startup.command $rootname\_trj.psf  $rootname\_prod.lammpstrj
END2

open (lmprun, ">$rootname\_run.sh") ;
print lmprun $file_input2; 
close (lmprun) ;
system("chmod +x $rootname\_run.sh");
}



###
# get the dihedral coefficents 
###

 sub get_dihedral_coeffs {
  
       my ($dihedraltype) = @_ ;

my  $tor_num = @torsion_labels ;
# print " $tor_num \n"  ;

#     print "$dihedraltype \n" ;
     @dhtypes =  split('-',$dihedraltype); 

# set the match flag
 $nomatch = 1 ;

  #   print "$torsion_labels[1] \n" ;

 for (my $i=0; $i <= $tor_num; ++$i) {
  # check to see is the strings matche correctly    
   if ($dihedraltype eq $torsion_labels[$i]){
             $Kphi =  sprintf "%.6f", $Kphis[$i] ;
             $n    =  sprintf "%d", $ns[$i] ; 
             $Phi0 =  sprintf "%d", -$Phi0s[$i] ; 
             $nomatch = 0;  }
    } # end looping through dihedrals  
  
     if ($nomatch == 1){
      # change the first type to an X
         $newdhtype =  'X-'.$dhtypes[1].'-'.$dhtypes[2].'-'.$dhtypes[3] ;
                                               
 #    print "$newdhtype \n" ;
             
 for (my $i=0; $i <= $tor_num; ++$i) {
  # check to see is the new strings match correctly    
   if ($newdhtype eq $torsion_labels[$i]){
             $Kphi =  sprintf "%.6f", $Kphis[$i] ;
             $n    =  sprintf "%d", $ns[$i] ; 
             $Phi0 =  sprintf "%d", -$Phi0s[$i] ; 
             $nomatch = 0;  }
    } # end looping through dihedrals  
                        }  # first nomatch 
                     
     if ($nomatch == 1){
      # only change the last type to an X
         $newdhtype =  $dhtypes[0].'-'.$dhtypes[1].'-'.$dhtypes[2].'-X' ;

  #   print "$newdhtype \n" ;

 for (my $i=0; $i <= $tor_num; ++$i) {
  # check to see is the new strings match correctly    
   if ($newdhtype eq $torsion_labels[$i]){
             $Kphi =  sprintf "%.6f", $Kphis[$i] ;
             $n    =  sprintf "%d", $ns[$i] ; 
             $Phi0 =  sprintf "%d", -$Phi0s[$i] ; 
             $nomatch = 0; } 
    } # end looping through dihedrals  

                      } # second nomatch 

     if ($nomatch == 1){
      # now change the start and last type to an X
         $newdhtype =  'X-'.$dhtypes[1].'-'.$dhtypes[2].'-X' ;
   #  print "$newdhtype \n" ;

 for (my $i=0; $i <= $tor_num; ++$i) {
  # check to see is the new strings match correctly    
   if ($newdhtype eq $torsion_labels[$i]){
             $Kphi =  sprintf "%.6f", $Kphis[$i] ;
             $n    =  sprintf "%d", $ns[$i] ; 
             $Phi0 =  sprintf "%d", -$Phi0s[$i] ; 
             $nomatch = 0;  }
                                 } # end looping through dihedrals  
            } # third nomatch 

# if it still can't find it you need to flip the torsion around 

     if ($nomatch == 1){
      # flip the string
         $newdhtype =  $dhtypes[3].'-'.$dhtypes[2].'-'.$dhtypes[1].'-'.$dhtypes[0] ;
                                               
   #  print "$newdhtype \n" ;
             
 for (my $i=0; $i <= $tor_num; ++$i) {
  # check to see is the new strings match correctly    
   if ($newdhtype eq $torsion_labels[$i]){
             $Kphi =  sprintf "%.6f", $Kphis[$i] ;
             $n    =  sprintf "%d", $ns[$i] ; 
             $Phi0 =  sprintf "%d", -$Phi0s[$i] ; 
             $nomatch = 0;  }
    } # end looping through dihedrals  
                        }  # fouth nomatch 


     if ($nomatch == 1){
      # change the first type in the fliped string to an X
         $newdhtype =  'X-'.$dhtypes[2].'-'.$dhtypes[1].'-'.$dhtypes[0] ;
                                               
   #  print "$newdhtype \n" ;
             
 for (my $i=0; $i <= $tor_num; ++$i) {
  # check to see is the new strings match correctly    
   if ($newdhtype eq $torsion_labels[$i]){
             $Kphi =  sprintf "%.6f", $Kphis[$i] ;
             $n    =  sprintf "%d", $ns[$i] ; 
             $Phi0 =  sprintf "%d", -$Phi0s[$i] ; 
             $nomatch = 0;  }
    } # end looping through dihedrals  
                        }  # fith nomatch 

     if ($nomatch == 1){
      # change the first type in the fliped string to an X
         $newdhtype =  $dhtypes[3].'-'.$dhtypes[2].'-'.$dhtypes[1].'-X' ;
                                               
   #  print "$newdhtype \n" ;
             
 for (my $i=0; $i <= $tor_num; ++$i) {
  # check to see is the new strings match correctly    
   if ($newdhtype eq $torsion_labels[$i]){
             $Kphi =  sprintf "%.6f", $Kphis[$i] ;
             $n    =  sprintf "%d", $ns[$i] ; 
             $Phi0 =  sprintf "%d", -$Phi0s[$i] ; 
             $nomatch = 0;  }
    } # end looping through dihedrals  
                        }  # six nomatch 

     if ($nomatch == 1){
      # change the second type in the flipped string to an X
         $newdhtype =  'X-'.$dhtypes[2].'-'.$dhtypes[1].'-X' ;
                                               
   #  print "$newdhtype \n" ;
             
 for (my $i=0; $i <= $tor_num; ++$i) {
  # check to see is the new strings match correctly    
   if ($newdhtype eq $torsion_labels[$i]){
             $Kphi =  sprintf "%.6f", $Kphis[$i] ;
             $n    =  sprintf "%d", $ns[$i] ; 
             $Phi0 =  sprintf "%d", -$Phi0s[$i] ; 
             $nomatch = 0;  }
    } # end looping through dihedrals  
                        }  # seven nomatch 


     if ($nomatch == 1){print "not able to match avaliable torsions --check your .frc for errors \n"; }
                                       
        return ($Kphi, $n, $Phi0);
}  #end subroutine dihedral assignment  


##############################
# get the pair coefficents 
#####################################

 sub get_pair_coeffs {
  
       my ($atomtype) = @_ ;

my  $nb_num = @nonbond_labels ;
# print " $nb_num \n"  ;
 for (my $i=0; $i <= $nb_num; ++$i) {
      if ($atomtype eq $nonbond_labels[$i]){
             $eps = sprintf "%.15f", -$eps[$i] ;
            $Rmin =  sprintf "%.6f", $Rmins[$i] ; $nonmatch = 0 ; }
  #  print  "$nonbond_labels[$i] $eps[$i] $Rmins[$i]  \n" ;
                                          }
     if ($nonmatch != 0){print "not able to match all pair terms --check your .frc for errors \n"; }
        return ($eps, $Rmin);
} 

 
#########################################
# dump torsion data into some arays for later processing 
################################

 sub get_torsion_data { 
 
       my ($frc_file) = @_ ;

 my @torsion_labels = (); 
 my @Kphis = ();
 my @ns = ();
 my @Phi0s = (); 

 open (frc, $frc_file) ;
 while(<frc>) { 

# last if(/END/);
if(/torsion_1/../nonbond/) {
next if /\!/ ;
next unless (/^\s*1.0/) ;
s/\r//g ;                # get rid any ^M after the line 'carrage return' 
chomp;
# print $_ ;
# next if /ANGLES/ ;
# next if /DIHEDRALS/ ;
 my @line = split ;
    my  $atom1 = sprintf "%s", $line[2];
    my  $atom2 = sprintf "%s", $line[3];
    my  $atom3 = sprintf "%s", $line[4];
    my  $atom4 = sprintf "%s", $line[5];
    my   $Kphi = sprintf "%.4f",$line[6];
    my   $n =    sprintf "%d",$line[7];
    my   $Phi0 = sprintf "%.4f",$line[8];
# turn the wildcards to X
      $atom1 =~ s/\*/X/g ;
      $atom4 =~ s/\*/X/g ;

my $torsion_label = $atom1.'-'.$atom2.'-'.$atom3.'-'.$atom4 ; 

  push (@torsion_labels, $torsion_label);
  push (@Kphis, $Kphi);
  push (@ns, $n);
  push (@Phi0s, $Phi0);

    }
 }  # end while 

close(frc);

        return (\@torsion_labels, \@Kphis, \@ns, \@Phi0s);

} # end subroutine get torsion  
#############################
#finish getting torsion data 
#######################




#########################################
# dump non-bond data into some arays for later processing 
################################

 sub get_nonbond_data { 
 
       my ($frc_file) = @_ ;

 my @nonbond_labels = (); 
 my @epss = ();
 my @Rmins = ();

 open (frc, $frc_file) ;
 while(<frc>) { 

# last if(/END/);
if(/NONBONDED/../END/) {
next if /\!/ ;
# next unless (/^\s*1.0/) ;
s/\r//g ;                # get rid any ^M after the line 'carrage return' 
chomp;
# print $_ ;
# next if /ANGLES/ ;
# next if /DIHEDRALS/ ;
 my @line = split ;
    my  $nonbond_label = sprintf "%s", $line[0];
    my   $eps = sprintf "%.6f",$line[2];
    my   $Rmin =  sprintf "%.6f",$line[3];

  push (@nonbond_labels, $nonbond_label);
  push (@epss, $eps);
  push (@Rmins, $Rmin);

    }
 }  # end while 

close(frc);

        return (\@nonbond_labels, \@epss, \@Rmins);

} # end subroutine get torsion  
#############################
#finish getting torsion data 
#######################
